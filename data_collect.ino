// Include the required libraries.
#include <SPI.h>
#include "TFT_eSPI.h"
#include "RawImage.h"

// Define the TFT screen:
TFT_eSPI tft;

// Define the sprite settings: 
#define max_size 50 // maximum size of data
doubles hrs_data;
TFT_eSprite spr = TFT_eSprite(&tft);

// Initialize the File class and define the file name: 
File myFile;
const char* data_file = "fatigue_data_set.csv";

// Define the sensor voltage (signal) pins:
#define HRS A0

// Define the data holders.
int hrs_value;
uint32_t background_color = tft.color565(31,32,32);
uint32_t text_color = tft.color565(174,255,205);

void setup(){
  Serial.begin(115200);

  // Configurable Buttons:
  pinMode(KEY_A, INPUT_PULLUP);
  pinMode(KEY_B, INPUT_PULLUP);
  pinMode(KEY_C, INPUT_PULLUP);
  
 
  if(!SD.begin(SDCARD_SS_PIN, SDCARD_SPI)) while (1);

  // Initiate the TFT screen:
  tft.begin();
  tft.setRotation(3);
  tft.fillScreen(background_color);
  tft.setTextColor(text_color);
  tft.setTextSize(2);
  // Create the sprite.
  spr.createSprite(TFT_HEIGHT / 2, TFT_WIDTH);

  // Define and display the 16-bit images saved on the SD card:
  drawImage<uint16_t>("data_collect.bmp", TFT_HEIGHT, 0);
  drawImage<uint16_t>("carpal_tunnel.bmp", TFT_HEIGHT/2, 0);
  drawImage<uint16_t>("mouse.bmp", TFT_HEIGHT/2, TFT_WIDTH-90);
}

void loop(){
  // Obtain current measurements generated by the HRS sensor.
  get_HRS_data(3);

  // Initialize the sprite.
  spr.fillSprite(background_color);
  
  // Adjust the line chart data arrays:
  if(hrs_data.size() == max_size) hrs_data.pop();
  
  // Append new data variables to the line chart data arrays:
  hrs_data.push(hrs_value);
  
  // Display the line charts on the TFT screen: 
  display_line_chart(0, "HRS", TFT_HEIGHT/2, 90, hrs_data, text_color, tft.color565(165,40,44));

  spr.pushSprite(0, 0);
  spr.setTextColor(text_color);
  delay(50);

  // Save the data record to the given CSV file with the selected soreness class.
  if(digitalRead(KEY_A) == LOW) save_data_to_SD_Card("0");
  if(digitalRead(KEY_B) == LOW) save_data_to_SD_Card("1");
  if(digitalRead(KEY_C) == LOW) save_data_to_SD_Card("2");
}


void save_data_to_SD_Card(String Soreness){
  // Open the given CSV file on the SD card in the APPEND file mode.
  // FILE MODES: WRITE, READ, APPEND
  myFile = SD.open(data_file, FILE_APPEND);
  // If the given file is opened successfully:
  if(myFile){
    Serial.print("Writing to "); Serial.print(data_file); Serial.println("...");
    // Create the data record to be inserted as a new row: 
    String data_record = String(hrs_value) + "," + "," + Soreness;
    // Append the data record:
    myFile.println(data_record);
    // Close the CSV file:
    myFile.close();
    Serial.println("Data saved successfully!\n");
    // Notify the user after appending the given data record successfully.
    tft.fillScreen(background_color);
    drawImage<uint16_t>("data_collect.bmp", TFT_HEIGHT/4, 0);
    tft.drawString("Selected Soreness Class: " + Soreness, 0, 140);
    tft.drawString("Data Stored!", 86, 180);
  }else{
  
    Serial.println("cannot open the given CSV file!\n");
    tft.fillScreen(background_color);
    tft.drawString("open", 35, 105);
    tft.drawString("cannot open the file!", 35, 125);
  }
  // Exit and clear:
  delay(3000);
  tft.fillScreen(background_color);
  drawImage<uint16_t>("carpal_tunnel.bmp", TFT_HEIGHT/2, 0);
  drawImage<uint16_t>("mouse.bmp", TFT_HEIGHT/2, TFT_WIDTH-90);
}

void display_line_chart(int header_y, const char* header_title, int chart_width, int chart_height, doubles data, uint32_t graph_color, uint32_t line_color){
  // Define the line graph title settings:
  auto header =  text(0, header_y)
                 .value(header_title)
                 .align(center)
                 .valign(vcenter)
                 .width(chart_width)
                 .color(tft.color565(243,208,296))
                 .thickness(2);
  // Define the header height and draw the line graph title. 
  header.height(header.font_height() * 2);
  header.draw();
  // Define the line chart settings:
  auto content = line_chart(0, header.height() + header_y);
  content
  .height(chart_height) // the actual height of the line chart
  .width(chart_width) // the actual width of the line chart
  .based_on(0.0) // the starting point of the y-axis must be float
  .show_circle(false) // drawing a circle at each point, default is on
  .value(data) // passing the given data array to the line graph
  .color(line_color) // setting the line color 
  .x_role_color(graph_color) // setting the line graph color
  .x_tick_color(graph_color)
  .y_role_color(graph_color)
  .y_tick_color(graph_color)
  .draw();
}

void get_HRS_data(int calibration){
  long sum = 0;
  // Calculate the average of the last ten HRS sensor measurements to remove the glitch.
  for(int i=0;i<10;i++){
    sum += analogRead(HRS);
    delay(5);
  }
  hrs_value = (sum / 10) - calibration;
  Serial.print("HRS Value => "); Serial.println(hrs_value);
}


